-- PK 중복이 없는 경우의 TEST01, TEST02 데이터는 STAT_CD와 FA_ID만 변환하여 통합
/* (PK중복) TEST02의 데이터로 통합되는 경우 : (TEST01.STAT_TYP, TEST02.STAT_TYP)가 각각
(LOADING, RESERVE)
(PROCESS, SELECT)
(RESERVE, PROCESS)
(SELECT, LOADING)
인 경우이고, 나머지는 TEST01로 통합
*/

INSERT INTO TEST03.TBL_LT_HIS C
SELECT * FROM (
WITH R AS (
    SELECT A.FA_ID  AS    FA_ID_M1  
    , A.LT_ID    AS  LT_ID_M1
    , A.PROD_ID    AS PROD_ID_M1
    , A.TIMEKEY    AS TIMEKEY_M1
    , A.FL_ID      AS FL_ID_M1
    , A.OP_ID      AS OP_ID_M1
    , A.STAT_CD    AS STAT_CD_M1
    , A.STAT_TYP   AS STAT_TYP_M1
    , B.FA_ID  AS    FA_ID_M2  
    , B.LT_ID    AS  LT_ID_M2
    , B.PROD_ID    AS PROD_ID_M2
    , B.TIMEKEY    AS TIMEKEY_M2
    , B.FL_ID      AS FL_ID_M2
    , B.OP_ID      AS OP_ID_M2
    , B.STAT_CD    AS STAT_CD_M2
    , B.STAT_TYP   AS STAT_TYP_M2
    FROM TEST01.TBL_LT_HIS A
    FULL OUTER JOIN
    TEST02.TBL_LT_HIS B
    ON A.FA_ID = B.FA_ID
    AND A.LT_ID = B.LT_ID
    AND A.PROD_ID = B.PROD_ID
    AND A.TIMEKEY = B.TIMEKEY
    )
    --TEST01 데이터 넣는 쿼리
    SELECT CASE FA_ID_M1 WHEN 'F12' THEN 'F11' ELSE FA_ID_M1 END,
        LT_ID_M1, PROD_ID_M1, TIMEKEY_M1, FL_ID_M1, OP_ID_M1, 
        CASE STAT_CD_M1 WHEN 'SHIP' THEN 'SHIPPED' WHEN 'SCRP' THEN 'SCRAPPED' 
        WHEN 'RELE' THEN 'RELEASED' ELSE STAT_CD_M1 END, 
        STAT_TYP_M1
    FROM R
    WHERE FA_ID_M1 IS NOT NULL
    AND FA_ID_M2 IS NULL
    UNION ALL
    --TEST02 데이터 넣는 쿼리
    SELECT CASE FA_ID_M2 WHEN 'F12' THEN 'F11' ELSE FA_ID_M2 END, 
        LT_ID_M2, PROD_ID_M2, TIMEKEY_M2, FL_ID_M2, OP_ID_M2, 
        CASE STAT_CD_M2 WHEN 'SHIP' THEN 'SHIPPED' WHEN 'SCRP' THEN 'SCRAPPED' 
        WHEN 'RELE' THEN 'RELEASED' ELSE STAT_CD_M1 END,
        STAT_TYP_M2
    FROM R
    WHERE FA_ID_M1 IS NULL
    AND FA_ID_M2 IS NOT NULL
    UNION ALL
    --PK중복 발생, TEST02 우선해서 통합하는 경우
    SELECT FA_ID_M2, LT_ID_M2, PROD_ID_M2, TIMEKEY_M2, FL_ID_M2, OP_ID_M2, 
        CASE STAT_CD_M2 WHEN 'SHIP' THEN 'SHIPPED' WHEN 'SCRP' THEN 'SCRAPPED' 
        WHEN 'RELE' THEN 'RELEASED' ELSE STAT_CD_M1 END,
        STAT_TYP_M2
    FROM R
    WHERE FA_ID_M1 IS NOT NULL
    AND FA_ID_M2 IS NOT NULL
    AND ((STAT_TYP_M1 = 'LOADING' AND STAT_TYP_M2 = 'RESERVE')
        OR (STAT_TYP_M1 = 'PROCESS' AND STAT_TYP_M2 = 'SELEECT')
        OR (STAT_TYP_M1 = 'RESERVE' AND STAT_TYP_M2 = 'PROCESS')
        OR (STAT_TYP_M1 = 'SELEECT' AND STAT_TYP_M2 = 'LOADING'))
    UNION ALL 
    --PK중복 발생, TEST01 우선해서 통합하는 경우
    SELECT FA_ID_M1, LT_ID_M1, PROD_ID_M1, TIMEKEY_M1, FL_ID_M1, OP_ID_M1, 
        CASE STAT_CD_M1 WHEN 'SHIP' THEN 'SHIPPED' WHEN 'SCRP' THEN 'SCRAPPED' 
        WHEN 'RELE' THEN 'RELEASED' ELSE STAT_CD_M1 END, 
        STAT_TYP_M1
    FROM R
    WHERE FA_ID_M1 IS NOT NULL
    AND FA_ID_M2 IS NOT NULL
    AND NOT ((STAT_TYP_M1 = 'LOADING' AND STAT_TYP_M2 = 'RESERVE')
        OR (STAT_TYP_M1 = 'PROCESS' AND STAT_TYP_M2 = 'SELEECT')
        OR (STAT_TYP_M1 = 'RESERVE' AND STAT_TYP_M2 = 'PROCESS')
        OR (STAT_TYP_M1 = 'SELEECT' AND STAT_TYP_M2 = 'LOADING'))
    );
    
    
/* 
JOIN : 
NL JOIN : INDEX 존재, A가 선행테이블이라면 A_IDX가 반드시 존재, B는 IDX 무관, A_IDX에서 데이터 찾고 A에 RANDOM ACSESS, B와 같다면 집합에 저장해 집합 RETURN
        >> JOIN이 많으면 자연스럽게 성능저하, 데이터 양이 적을 때 빠른 편
NESTED LOOPS :
SORT MERGE : A, B를 정렬해 MERGE
HASH JOIN : EQUI JOIN에 사용(FAC_ID >= B.FAC_ID 와 같은 NON-EQUI에는 사용불가), 빈번하게 사용 시 HASH 테이블의 사이즈가 임시저장공간보다 커질 수 있으므로 조심
WITH R AS: HASH JOIN과 같이 TEMPORARY영역 사용하므로 동시에 여러번 사용하지 않도록 조심, FROM절 안에 사용될 경우 INLINE VIEW이므로 무관, DATA MIGRATION에 주로 이용
*/
-- SELECT /*+APPEND*/ ~~ : DIRECT PATH LOADING
